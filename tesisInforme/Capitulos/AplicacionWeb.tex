En este capítulo, se introduce una aplicación web diseñada para interactuar con el datalogger descrito en el capitulo anterior, con el objetivo de optimizar la calibración de anemómetros. Esta herramienta de software simplifica la carga de metadatos esenciales, incluyendo la información de los sensores de referencia y los sensores bajo calibración, los certificados de calibración y las especificaciones de la zona de medición del túnel de viento.

La aplicación ofrece la posibilidad de configurar el datalogger, definiendo la interfaz eléctrica de los anemómetros, los intervalos de muestreo y procesamiento de datos, y los puntos de medición de la velocidad del viento. Además, permite establecer los tiempos de encendido y el periodo de estabilidad en cada punto de medición. Una vez configurado el sistema, el software inicia el proceso de medición, enviando referencias de viento al hardware. Este último interactúa con el túnel de viento a través de su controlador PID para ajustar la velocidad del viento al valor deseado. Las mediciones obtenidas son verificadas por el operador y, si son correctas, se calcula automáticamente la incertidumbre expandida. Los resultados se presentan en el front end, en gráficos y tablas, se almacenan en una base de datos y pueden descargarse para emitir el certificado de calibración correspondiente.

La integración de esta aplicación con el datalogger automatiza y estandariza el proceso de calibración, reduciendo de manera significativa el tiempo dedicado al procesamiento manual de datos y a la separación de estos en diferentes etapas. Esto contribuye a la reducción de tiempos operativos y minimiza errores sistemáticos, mejorando notablemente la calidad y precisión en la calibración de sensores de viento de ultrasonido.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Desarrollo aplicación WEB}
% hablar de las herramientas utilizadas para todo el desarrollo, contar todo, los entornos, lenguajes y frameworks etc
Durante el desarrollo de la aplicación web, se emplearon diversas herramientas para llevar a cabo el proyecto de manera eficiente. Se utilizó Django en su versión 4.2 como framework principal, junto con Python 3.10, proporcionando una base sólida y flexible para el desarrollo back end. Para la gestión de la base de datos, se optó por PostgreSQL en su versión 15 y se utilizó PGAdmin 4 para gestionar dicha base de datos. La conexión entre Django y PostgreSQL se realizó utilizando PSYCOPG2 en su versión 2.9.5.

En el frontend, se emplearon JavaScript y jQuery para hacer la página web dinámica y permitir la visualización de datos actualizados en tiempo real. También se utilizaron HTML y CSS para estructurar y estilizar el contenido de la aplicación web. Además, se emplearon herramientas como NumPy 1.24.2, SciPy  1.11.2 para el procesamiento de datos y Plotly 5.15 para generar gráficos dinámicos, así como Pandas 2.2 para la manipulación de datos.

Adicionalmente, se trabajó en un servidor local, dentro de un entorno virtual de Python para mantener las dependencias aisladas y facilitar la portabilidad del proyecto a otros entornos. Se gestionó el control de versiones con Git y GitHub, en el repositorio \url{https://github.com/InstrumentalSMN/AppWebSistemaDecalibracion/tree/develop_apps}, subiendo el código y trabajando en distintas ramas para luego integrar los cambios en la rama principal, lo que permitió mantener un historial claro de los cambios realizados.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Arquitectura del software}
Para desarrollar la aplicación, se utilizó una arquitectura de cinco capas, como se muestra en la Figura \ref{fig:arquitecturaSoft}. La primera capa está conformada por el servidor web Nginx, que actúa como un servidor \textit{proxy} inverso. Nginx se encarga de manejar las solicitudes HTTP entrantes, distribuyéndolas eficientemente y proporcionando un equilibrio de carga, además de servir contenido estático como archivos CSS, JavaScript e imágenes. Esta capa permite mejorar el rendimiento y la seguridad de la aplicación al filtrar y dirigir el tráfico de manera óptima.

La segunda capa está compuesta por Gunicorn, un servidor WSGI (\textit{Web Server Gateway Interface}) que sirve como intermediario entre Nginx y la aplicación web desarrollada en Django. Gunicorn se encarga de gestionar los procesos de la aplicación, proporcionando un entorno escalable y capaz de manejar múltiples solicitudes concurrentes. Esta capa es crucial para asegurar que la aplicación pueda responder de manera rápida y eficiente a las demandas de los usuarios.

En la tercera capa se encuentra la aplicación web desarrollada en Django, un \textit{framework} de alto nivel que facilita el desarrollo rápido y eficiente de aplicaciones web seguras y mantenibles.  Esta capa es responsable de la lógica de negocio de la aplicación, la gestión de las bases de datos y la interacción con los usuarios a través de interfaces web dinámicas.


La cuarta capa está constituida por el sistema de gestión de bases de datos PostgreSQL, encargado del almacenamiento y recuperación de datos de manera eficiente y segura. La integración con Django se realiza a través de su ORM (\textit{Object-Relational Mapping}), que permite interactuar con la base de datos utilizando objetos en Python. Las tablas se definen creando una clase que hereda de \texttt{models.Model} de Django, donde los campos se establecen como atributos de la clase. Esto permite crear registros, guardar información y realizar consultas de manera sencilla, traduciendo automáticamente las operaciones en Python a consultas SQL en la base de datos. Esta abstracción de los detalles subyacentes de la implementación facilita la gestión y manipulación de datos, mejorando la eficiencia en el desarrollo de aplicaciones web.




Finalmente, la quinta capa consiste en un servidor WebSocket que se conecta con un sistema embebido. Este servidor permite la comunicación bidireccional en tiempo real entre la aplicación y dispositivos embebidos, facilitando el control y monitoreo remoto. Esta capa es esencial para aplicaciones que requieren actualizaciones en tiempo real y una interacción continua con dispositivos de hardware.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{Figuras/AplicacionWeb/arquitecturaSoft.png}
    \caption{Arquitectura del software implementada.}
    \label{fig:arquitecturaSoft}
\end{figure}
Se empleó el patrón de diseño MVT (Modelo-Vista-Plantilla), ilustrado en la Figura \ref{fig:patronMVT}. Este patrón es ampliamente utilizado en el desarrollo web con el \textit{framework} de trabajo Django. El patrón MVT permite una distinción explícita de las responsabilidades, lo que facilita tanto el desarrollo como el mantenimiento del código.

\begin{itemize}
    \item \textbf{Modelo (M)}: Representa la capa de acceso a la base de datos (ORM). Contiene toda la información sobre los datos, cómo acceder a ellos, validarlos, su comportamiento y las relaciones entre ellos.
    \item \textbf{Vista (V)}:  Corresponde a la capa de lógica de negocios. Se encarga de procesar las solicitudes del navegador y recuperar los datos necesarios del modelo. Luego, renderiza la plantilla (template) para mostrar el HTML resultante.
    \item \textbf{Template (T)}: (Plantilla), representa la capa de presentación, es la parte visual de la aplicación. El template integra los datos dinámicos recuperados del modelo y genera el HTML final que se envía al navegado

\end{itemize}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{Figuras/AplicacionWeb/patronMVT.png}
    \caption{Patrón de diseño de software MVT, que divide la lógica del programa en tres elementos interconectados.}
    \label{fig:patronMVT}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Back End}\label{sec:back_end}
El back end se encarga de:
\begin{itemize}
    \item Administrar la base de datos, incluyendo la ejecución de consultas, la realización de actualizaciones y la aplicación de validaciones para garantizar la integridad y consistencia de la información.
    \item Recibir o gestionar solicitudes HTTP y conexiones al servidor WebSocket.
    \item Enviar comandos de configuración hacia el datalogger y gestionar la recepción de mediciones de los sensor.
    \item Generar un perfil de referencias de velocidad de viento almacenadas en la base de datos, que se van a transmitir al datalogger para controlar el motor del túnel.
    \item A partir de las mediciones crudas de velocidades de viento, calcular el presupuesto de incertidumbre de la corrección.
\end{itemize}

\subsubsection{Base de datos}

Dado que la aplicación está diseñada para manejar una gran cantidad de datos que requieren almacenamiento y recuperación eficientes, se ha implementado una base de datos relacional. El diagrama entidad-relación, presentado en la figura \ref{fig:DiagramaEntidadRelacion}, ilustra la estructura de la base de datos. Esta estructura incluye diversas tablas que almacenan información crucial para la aplicación. Entre estas tablas se encuentran las que registran los datos del sensor patrón y el sensor bajo calibración, así como los detalles relacionados con el certificado de calibración del patrón. Además, se documentan los registros del certificado de caracterización del túnel de viento. También se incluye información sobre la configuración del datalogger y del túnel de viento.


Cuando se inicia una calibración y se empiezan a recibir datos de los sensores, toda esta información se almacena en una tabla \texttt{DatosMedidos2023} de la base de datos. Asimismo, se guardan los resultados generados antes y después del procesamiento de los datos, como gráficos y tablas.

Todas estas tablas están relacionadas mediante claves foráneas (relación de uno a muchos) con la tabla de \texttt{Calibración}. Esto se debe a que una calibración está asociada a un único datalogger o a un único sensor IBC, y se puede recuperar la información de esa calibración a través clave primaria.


\begin{figure}[H]
    \centering
    \includegraphics[width=1.1\linewidth]{Figuras/AplicacionWeb/backend/DiagramaEntidadrelacion.png}
    \caption{Diagrama entidad relación diseñada para la aplicación Web.}
    \label{fig:DiagramaEntidadRelacion}
\end{figure}

% Todo las definiciones de estas tablas se realizaron a traves de clases usando el Conector de ORM de django con la base de datos Postggre SQL, a traves de la definir una clase que hereda de models.Model, como se ve en el codigo \ref{}, donde se define la clase,  ConfigTunel
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Servidor WebSocket}

Se utilizó la biblioteca Django-channels para implementar un servidor WebSocket que opera de forma concurrente con el servidor web HTTP. Este servidor permite la conexión simultánea de múltiples clientes, en este caso, un datalogger que envía datos y un usuario que recibe dicha información a través de WebSockets. Los datos recibidos por el servidor, son graficados y actualizados en tiempo real en la aplicación web.

Para configurar el servidor, se creó el archivo \texttt{routing.py}, el cual define las rutas de los canales, es decir, los puntos de acceso a los consumidores (consumers) que gestionan las conexiones WebSocket. La configuración del archivo \texttt{routing.py} se presenta en el Código \ref{cdg:routing}. Cada ruta mapea una URL de WebSocket a un consumidor específico. En este caso, \texttt{ChatConsumer} es una clase que maneja las conexiones a la URL \texttt{ws/socket-server/}.



\begin{lstlisting}[style=pythonstyle, caption={Configuracion del routing para gestionar las conexiones de clientes al servidor WebSocket.}, label=cdg:routing,basicstyle=\ttfamily\fontsize{8}{8}\selectfont]
from django.urls import re_path
from . import consumers

websocket_urlpatterns = [
    re_path(r'ws/socket-server/',consumers.ChatConsumer.as_asgi())
]
\end{lstlisting}

También se creo el archivo \texttt{consumers.py} define las clases de consumidores que manejan las conexiones WebSocket. Un consumidor en Django-channels es una clase que gestiona la conexión con el cliente, incluyendo el manejo de eventos como la recepción y el envío de mensajes. En el codigo \ref{cdg:consumer} se muestra el consumidor implementado

\begin{lstlisting}[style=pythonstyle, caption={Declaracion de las funciones que utiliza cada consumidor para interactuar con el servidor WebSocket.}, label=cdg:consumer,basicstyle=\ttfamily\fontsize{8}{8}\selectfont]
class ChatConsumer(WebsocketConsumer):
    def connect(self):
        self.room_group_name = 'test'
        async_to_sync(self.channel_layer.group_add)(
            self.room_group_name,
            self.channel_name           
        )
        self.accept()

    def disconnect(self, close_code):
        pass
        
    def receive(self, text_data):
        text_data_json = json.loads(text_data)
        message = text_data_json['message']
        # message = text_data
        async_to_sync(self.channel_layer.group_send)(
            self.room_group_name,
            {
                'type': 'chat_message',
                'message': message,
                'sender_channel_name': self.channel_name,
            }
        )
        if(len(message)>0):
            if(message[0] == "M"):
                saveMesuareDataBase(message)
        print('Message:', message)

    def chat_message(self, event):
        message = event['message']
        sender_channel_name = event['sender_channel_name']
        if sender_channel_name != self.channel_name:
            self.send(text_data=json.dumps({
                'type': 'chat',
                'message': message
            }))
\end{lstlisting}

En particular, se implementa la clase \texttt{ChatConsumer}, que hereda de \texttt{WebsocketConsumer}, para gestionar las conexiones WebSocket. Esta clase define varios métodos, incluyendo \texttt{connect}, \texttt{disconnect}, \texttt{receive} y \texttt{chat\_message}.

El método \texttt{connect} se ejecuta cuando un cliente se conecta al servidor WebSocket. Dentro de este método, se asigna el nombre del grupo de la sala a \texttt{self.room\_group\_name} y se añade el canal del cliente al grupo utilizando \texttt{async\_to\_sync(self.channel\_layer.group\_add)}. Finalmente, se acepta la conexión mediante \texttt{self.accept()}. Por otro lado, el método \texttt{disconnect} se ejecuta cuando un cliente se desconecta del servidor WebSocket.

El método \texttt{receive} recibe y decodifica los mensajes desde JSON para luego enviarlos a un grupo de la sala utilizando \texttt{async\_to\_sync(self.channel\_layer.group\_send)}. Los mensajes que envía el datalogger tiene la forma del arreglo declarado en código \ref{cdg:estructuraMensaje}, que contiene toda la información que ha recolectado el datalogger en un ciclo de iteración.


\begin{lstlisting}[style=cstyle, caption={Estructura del mensaje enviado por el datalogger}, label=cdg:estructuraMensaje, basicstyle=\ttfamily\fontsize{8}{8}\selectfont]
real32_t Tabla_Mediciones[25] = {
    velocidadInst, velocidadMin, velocidadMax, velocidadPromedio,
    velocidadInstIBC, velocidadMinIBC, velocidadMaxIBC, velocidadPromedioIBC,
    direccionInst, direccionMin, direccionMax, direccionPromedio,
    direccionInstIBC, direccionMinIBC, direccionMaxIBC, direccionPromedioIBC,
    nv_bateriaInst, nv_bateriaMin, nv_bateriaMax, nv_bateriaPromedio,
    nv_adcTunelInst, nv_adcTunelMin, nv_adcTunelMax, nv_adcTunelPromedio,
    nv_pwmControlTunelInst
};
\end{lstlisting}

El mensaje decodificado tiene la siguiente forma:
\begin{verbatim}
    
    poner numeros de la base de datos
    M;634;14-06-2024;16:42:41;
    10.08;10.08;10.08;10.08;
    9.53;9.53;9.53;9.53;
    169;169;169;169;
    175;175;175;175;
    12.02;12.02;12.02;12.02;
    1.25;1.25;1.25;1.25;
    90;
\end{verbatim}

De esta forma, si el mensaje recibido comienza con la letra "M", se guarda en la base de datos mediante la función \texttt{saveMeasureDataBase(message)}. Esta función conoce el orden en que se creó el string y separa los datos para guardarlos en su respectivo campo de la base de datos.

Finalmente, el método \texttt{chat\_message} se utiliza para enviar mensajes a los clientes. Si el mensaje recibido no se origina del mismo canal que el receptor, se envía el mensaje de vuelta al cliente utilizando \texttt{self.send()}. Por ejemplo, cuando un cliente está conectado al WebSocket desde el navegador web, puede ver cómo se grafican los datos en tiempo real a medida que estos llegan desde el datalogger hacia servidor.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Generador de trayectoria y control del túnel}\label{sec:genTrayec}

En la sección \ref{sec:sistemaDeControlPid} se ha detallado el funcionamiento del controlador PID del túnel de viento. Para que este funcione, necesita referencias que se construyen a partir de un generador de trayectoria utilizando el método de Paul \cite{RoboFIUBAGenTrayec}. El generador toma los valores de velocidad de viento deseados y los tiempos deseados desde la configuración realizada por el operador en el frontend, y con estos valores se genera una curva de referencia de velocidades de viento en función del tiempo.

El método de Paul consiste en definir, para cada punto, dos zonas: una de aceleración constante y otra de velocidad constante. Cada segmento tiene una duración $T_{j}$ y un tiempo de aceleración $t_{acc}$, como se muestra en la figura \ref{fig:segmentosZona1yZona2}, de forma tal que no se realicen cambios abruptos en el controlador, permitiendo que los cambios de velocidad del viento sean suaves.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\linewidth]{Figuras/AplicacionWeb/backend/segmentoTrayect.png}
    \caption{Segmento para pasar de un punto de velocidad $v^B$ a otro $v^C$ viniendo desde $v^A$.}
    \label{fig:segmentosZona1yZona2}
\end{figure}

Estos cambios suaves se traducen, a través del controlador PID, en cambios suaves en los valores de PWM para el motor.

Para la zona 2 del segmento $T_{j}$, donde se define $\Delta C = v^C - v^B$, el método de Paul aplica la ecuación \ref{eq:zona2MetodoPaul}:
\begin{equation}
    v(t_{seg}) = \frac{\Delta C}{T_j} + v^B
    \label{eq:zona2MetodoPaul}
\end{equation}

Para la zona 1 del mismo segmento, donde se define $\Delta A = v^A - v^B$, se aplica la ecuación \ref{eq:zona1MetodoPaul}:
\begin{equation}
    v(t_{seg}) = \frac{\Delta C}{T_j} \frac{(t_{seg} + t_{acc})^2}{4t_{acc}} + \frac{\Delta A}{t_{acc}} \frac{(t_{seg} - t_{acc})^2}{4t_{acc}} + v^B 
    \label{eq:zona1MetodoPaul}
\end{equation}

Esto garantiza que en la zona 1, donde se realiza el enganche de segmento, la aceleración del cambio sea constante, y que en la zona 2, donde se realiza la transición de un segmento a otro, la velocidad de cambio sea constante.

El algoritmo generador de trayectoria se muestra en el código \ref{cdg:genTrayectoria}. Este se ejecuta en el back end y calcula la trayectoria en función de cada punto de viento (segmento) y los tiempos de crecimiento, estabilización y medición configurados por el operador. Luego, realiza el encadenamiento de todas las velocidades para obtener un perfil como el de la Figura \ref{fig:trayectoriaGenerada}, donde se muestra una trayectoria de ciclo ascendente y descendente para los puntos 5, 10, 15, 20 y 25 \unit{\meter\per\second}, con un tiempo de crecimiento de 2 \unit{\minute}, un tiempo de estabilización de 5 \unit{\minute} y un tiempo de medición de 2 \unit{\minute}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{Figuras/AplicacionWeb/backend/trayectoriaGenerada.jpg}
    \caption{Trayectoria generada utilizando el método de Paul para un ciclo ascendente y descendente de velocidades.}
    \label{fig:trayectoriaGenerada}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Cálculo de incertidumbre}\label{sec:calculoIncertidumbre}

El proceso de calcular la incertidumbre expandida para todos los puntos medidos se realiza según el algoritmo del diagrama de flujo de la figura \ref{fig:DiagramaFlujoCalculoIncertidumbre}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\linewidth]{Figuras/AplicacionWeb/backend/DiagramaFlujoCalculoIncertidumbre.png}
    \caption{Diagrama de flujo del para el calculo de incertidumbre expandida.}
    \label{fig:DiagramaFlujoCalculoIncertidumbre}
\end{figure}

Después de completar los ciclos ascendente y descendente de medición, se dispone de un banco de datos crudos de velocidad y dirección. El algoritmo lee estos datos y extrae las mediciones de la parte plana estable para cada punto de forma iterativa. Este proceso se denomina \textit{parsear datos}. Luego, se muestran los datos crudos procesados en pantalla, donde el operador, desde el front-end, debe hacer clic en el botón ``Calcular Incertidumbre'', siempre que esté de acuerdo con los datos. Si no, puede reiniciar las mediciones con un nuevo perfil.

Si los datos son correctos para la calibración, se calcula el promedio $\bar{v}$ y el desvío estándar ($\sigma_{v}$) de las mediciones para cada punto. A continuación, se arma el presupuesto de incertidumbre, obteniendo los datos de histéresis del patrón y del IBC a partir de la diferencia de los datos promedio. Se realiza la lectura de la resolución de los instrumentos y el área de bloqueo de los anemómetros para el cálculo del factor de bloqueo, con el cual se corrigen las mediciones del IBC. Estos datos también son ingresados por el operador.

Luego, se obtienen los datos de calibración del sensor patrón a partir de un ajuste lineal de los puntos discretos del certificado y evaluando los puntos configurados por el operador. Esto se hace así porque no siempre el patrón está calibrado en los mismos puntos en los que se lo va a utilizar. Lo mismo se realiza con el certificado del túnel, extrayendo los valores de estabilidad, homogeneidad y el factor de calibración del túnel para los puntos configurados por el operador.

Con todas estas incertidumbres normalizadas y multiplicadas por su coeficiente de sensibilidad $c_{i}$, se obtiene la incertidumbre estándar para cada punto. Luego, se realiza la suma de los cuadrados de cada incertidumbre y se calcula la raíz cuadrada para obtener la incertidumbre combinada para cada punto
\[
u_c = \sqrt{\sum_{i=1}^{n} (u_i^2)}.
\]

En base al número de mediciones, se calculan los grados de libertad efectivos para cada punto y con este número, solicitando un intervalo de confianza del 95\%, se evalúa la distribución $t$ de Student para obtener el factor de cobertura ($k$). Luego, se multiplica este número por cada incertidumbre combinada correspondiente para obtener la incertidumbre expandida 
\[
U = k \cdot u_c.
\]

Finalmente, todos los resultados se presentan por pantalla y se dispone de botones para descargar los gráficos y tablas correspondientes a los datos crudos, la histéresis y los resultados de calibración.

% Luego, se grafica la curva de histéresis, como se muestra en la figura \ref{fig:CurvaHisteresis}, junto con una tabla para analizar la alinealidad del IBC (figura \ref{fig:TablaAlinealidad}). Además, se presenta la curva de calibración con sus correspondientes incertidumbres expandidas tanto para los datos del ciclo ascendente como del descendente (figura \ref{fig:CurvaCalibracion}). Finalmente, se incluye una tabla (figura \ref{fig:TablaIncertidumbres}) donde se especifican la incertidumbre combinada, la incertidumbre expandida, la corrección y los grados de libertad para cada punto donde se realizó la calibración del anemómetro.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Frond End}\label{sec:frondEnd}

El front end se encarga de:
\begin{itemize}
    \item Interacción del usuario a través de formularios, botones y eventos.
    \item Comunicación con el backend a través de Django y WebSockets.
    \item Presentación de tablas y gráficos al usuario (UI/UX).
\end{itemize}
La aplicación web presenta una plantilla de inicio, como se muestra en la figura \ref{fig:index}. En la cabecera se visualiza, el logotipo correspondiente al SMN, el nombre del sistema y el nombre y tipo de perfil de usuario. En el lado izquierdo, se encuentran cuatro botones: \texttt{Temperatura y humedad}, \texttt{Temperatura}, \texttt{Presión} y \texttt{Viento}, cada uno con su respectiva descripción. Este diseño permitirá escalar el software para incluir otras magnitudes con las que trabaja el laboratorio del SMN. En el pie de página, se presentan los enlaces a las herramientas utilizadas para desarrollar el proyecto.
\begin{figure}[H]
    \centering
    \includegraphics[width=1.1\linewidth]{Figuras/AplicacionWeb/frondend/index.jpg}
    \caption{Pantalla de inicio de la aplicación web.}
    \label{fig:index}
\end{figure}
El usuario hace click en el botón \texttt{Viento} y se activa la vista de la Figura \ref{fig:iniciarCalibViento}, donde le consulta al usuario, si desea iniciar o no una calibración de anemómetros.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{Figuras/AplicacionWeb/frondend/iniciarCalibViento.png}
    \caption{Vista para confirmar si se desea realizar o no una calibración.}
    \label{fig:iniciarCalibViento}
\end{figure}
Si el usuario responde afirmativamente, se abre a izquierda una barra de navegación, como se muestra en la figura \ref{fig:barraNavegIzq}, que permite navegar por la aplicación web. En el cuerpo de la aplicación se presenta una serie de formularios y botones para cargar los metadatos, configurar los equipos, iniciar las mediciones y, finalmente, procesar y presentar los resultados. Además, el usuario puede utilizar el botón \texttt{Salir}, que lo redirige a la pestaña de inicio.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.2\linewidth]{Figuras/AplicacionWeb/frondend/barraNavegIzq.png}
    \caption{Barra lateral izquierda de navegación.}
    \label{fig:barraNavegIzq}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Carga de metadatos}\label{sec:cargaMetadatos}

El contenido principal (\textit{main}) de la primera vista, llamada \texttt{Carga de Metadatos}, se muestra en la Figura \ref{fig:cargaMetadata}. En esta vista, se deben ingresar la marca, el modelo, el número de serie, el número de patrimonio (identificador de instrumentos del SMN), la resolución y el área de bloqueo del instrumento, medidos previamente con una cinta métrica, tanto del sensor patrón como del sensor bajo calibración. Luego, se debe cargar la información del certificado de calibración del instrumento patrón utilizado, incluyendo la fecha de generación, los puntos en los que fue calibrado, los valores obtenidos por cada punto, las correcciones obtenidas y su respectiva incertidumbre. Por último, se deben ingresar los datos del certificado de caracterización del túnel de viento, especificando la fecha de emisión, los puntos medidos en el ensayo, los valores de estabilidad y de homogeneidad del flujo de aire en la zona de medición. Además, se debe agregar el factor de calibración definido en la tabla \ref{tab:fuenteIncert}. Una vez cargada toda la información, el operador debe presionar el botón \texttt{Cargar}, o si desea borrar toda la información del formulario, debe presionar \texttt{Limpiar campos}. Parte de esta información luego será utilizada para el cálculo de la incertidumbre expandida del sensor bajo calibración y toda los datos ingresados se guardan en la base de datos.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Figuras/AplicacionWeb/frondend/cargaMetadata.png}
    \caption{Vista para cargar los metadatos de la calibración.}
    \label{fig:cargaMetadata}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Configuración del sistema}\label{sec:configSistema}

El contenido principal (\textit{main}) de la segunda vista, denominada \texttt{Configuración}, se muestra en la Figura \ref{fig:configEquipos}. En esta vista, a la izquierda, se configura el datalogger diseñado en el capítulo \ref{cap:datalogger}. Se pueden seleccionar la marca, el modelo y el número de serie del datalogger. Posteriormente, se especifica el tiempo de muestreo y el tiempo de tabla, se configuran los puertos de comunicación serie del datalogger, los LEDs de recepción y la velocidad en baudios para cada anemómetro.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Figuras/AplicacionWeb/frondend/configEquipos.png}
    \caption{Vista para configurar los equipos involucrados en la calibración.}
    \label{fig:configEquipos}
\end{figure}

A la derecha, se configura el túnel de viento. Aquí se establecen los puntos mínimo y máximo de velocidad, la cantidad de puntos donde se desea medir, los valores de velocidad en metros por segundo, y el tipo de perfil de medición, que puede ser ascendente, descendente o ambos. También se configuran los tiempos de transitorio, de estabilidad y de medición para cada punto, necesarios para generar el perfil de trayectoria explicado en la sección \ref{sec:genTrayec}. Estos tiempos se ilustran sobre el escalón de la Figura \ref{fig:curvaEscalon}.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Figuras/AplicacionWeb/frondend/curvaEscalon.png}
    \caption{Configuración de tiempos para el generador de trayectoria en $\SI{5}{meter\per\second}$.}
    \label{fig:curvaEscalon}
\end{figure}

Una vez que los datos de configuración están cargados, el usuario puede hacer clic en el botón \texttt{Cargar} para subirlos a la base de datos o en \texttt{Limpiar campos} para borrar los campos de esta vista.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Adquisición de datos}\label{sec:adquisicionDatos}

Una vez cargados todos los datos, el software muestra la vista de la Figura \ref{fig:adquisicionDatos}. Al hacer clic en el botón \texttt{Iniciar Medición}, se envían todas las configuraciones al datalogger a través del servidor WebSocket mediante comandos detallados en la Tabla \ref{tab:comandosParaconfig}. Luego, se activa un temporizador que multiplica el tiempo de un escalón, como el de la Figura \ref{fig:curvaEscalon}, por la cantidad de puntos ingresados e indica el tiempo restante para que termine todas las mediciones. 

El software también envía, a intervalos de un segundo, un valor de referencia del generador de trayectoria al datalogger para que éste genere un nivel de PWM y lo envíe al variador de velocidad del motor. Al mismo tiempo, se reciben las mediciones del sensor patrón e IBC, y se va construyendo el perfil de mediciones, con la dirección del viento a la izquierda y la velocidad a la derecha.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Figuras/AplicacionWeb/frondend/adquisicionDatos.png}
    \caption{Vista de la adquisición de datos.}
    \label{fig:adquisicionDatos}
\end{figure}

En caso de que el operador precise detener o reiniciar las mediciones puede activar el botón \texttt{Reiniciar Medición}, el cual genera la vista de la figura \ref{fig:borrarMediciones}, que informa que si reinicia se borraran las mediciones ya adquiridas.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{Figuras/AplicacionWeb/frondend/borrarMediciones.png}
    \caption{Vista para confirmar si se desea borrar o no los datos crudos de una calibración.}
    \label{fig:borrarMediciones}
\end{figure}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Procesamiento de datos}\label{sec:ProcesamientoDatos}
Luego de que se acabe el tiempo del temporizador, el software redirige a la vista \texttt{Procesamiento} que se muestra en la Figura \ref{fig:procesarDatos1}. En esta vista, se grafican las curvas ascendente y descendente de las velocidades de viento del sensor patron y bajo calibración. En el título del gráfico se indica la magnitud, el número de serie y patrimonio del sensor bajo calibración. Toda la información y datos se leen desde la base de datos, ya que se fueron almacenando en la misma a medida que ingresaron. Además, cada gráfico cuenta con un botón para ser descargado.

\begin{figure}[H]
    \centering
    \includegraphics[width=1.1\linewidth]{Figuras/AplicacionWeb/frondend/procesarDatos1.png}
    \caption{Vista para el procesamiento de datos y visualización de gráficos.}
    \label{fig:procesarDatos1}
\end{figure}

En la parte inferior de la vista, como se ve en la figura \ref{fig:procesarDatos2} se muestran tablas con los datos parseados, que corresponden a la extracción de los datos de la parte plana, equivalente añ tiempo de medición, como por ejemplo en el gráfico de la Figura \ref{fig:curvaEscalon}. El operador revisa estos datos y, si están dentro del entorno del punto de medición configurado, debe presionar el botón \texttt{Calcular Incertidumbre}. En caso contrario, puede reiniciar las mediciones, lo que lo devolverá a la vista de adquisición de datos. De igual forma cada tabla cuenta con un boton para ser descargado en formato $.csv$

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\linewidth]{Figuras/AplicacionWeb/frondend/procesarDatos2.png}
    \caption{Vista para la revisión de datos parseados y cálculo de incertidumbre.}
    \label{fig:procesarDatos2}
\end{figure}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Resultados}\label{sec:Resultados}
Cuando hace hace click en calcular incertidumbre se activa el programa del diagrama de flujo de la figura \ref{fig:DiagramaFlujoCalculoIncertidumbre}.

continuar aqui mañana
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Figuras/AplicacionWeb/frondend/curvaHisteris.png}
    \caption{.}
    \label{fig:curvaHisteris}
\end{figure}


\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\linewidth]{Figuras/AplicacionWeb/frondend/tablaHisteresis.png}
    \caption{.}
    \label{fig:tablaHisteresis}
\end{figure}



\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Figuras/AplicacionWeb/frondend/curvaCalib.png}
    \caption{.}
    \label{fig:curvaCalib}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\linewidth]{Figuras/AplicacionWeb/frondend/tablaCalib.png}
    \caption{.}
    \label{fig:tablaCalib}
\end{figure}



mostrar los resultados que muestra el soft como ejemplo usar los del segundo DeltaOHM
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Integración con el hardware}
Cuando tenga armado el PCB, hago una prueba de configuración del datalogger, configuración del túnel, metadatos para la calibración


diagrama de como queda todo el sistema, 
\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\linewidth]{Figuras/AplicacionWeb/integracionHardware/DiagramaSistemaDesarrollar.png}
    \caption{}
    \label{fig:}
\end{figure}


mostrar un diagrama de flujo desde el inicio con el boton calcular incertidumbre hasta la salida de tablas con los reusltados, pasos del proceso de calibración

%-----------------------------------------------------------------------------------------------------
